      NEXT CRASH COURSE BY TRAVERSY MEDIA

Source: https://www.youtube.com/watch?v=mTz0GXj8NN0

Next es un framework frontend creado por Vercel(anteriormente Zeit) que activa funcionalidades tales como SSR(Server Side Rendering) y generación estática de la website.
Básicamente Next está construido sobre React agregandole features extras.

               VENTAJAS

Con una app normal(usando create-react-app) todo se renderiza en el navegador.Alli habrá un html,un js y un css,lo cual hace extremadamente rápido el renderizado(a comparación con la forma anterior con PHP,que pedia los html,ya que el servidor compilaba el html y lo devolvia al cliente)
Si bien el Client Side Rendering es más rápido,tiene downsides,siendo el mayor el SEO.
Si abro una web React e inspecciono el código no veré el Html,ya que se va generando via Javascript en el background.Esto es fatal para los SEO crawlers,ya que no ven el etiquetado HTML.
NextJs arregla esto enviando la primera pag desde el server(dejando que los crawlers vean el contenido pues) 

Si bien está es la principal ventaja también tiene otras:
1- Easy page routing(ya no hay que usar react-router-dom y definir las rutas,basta con poner el componente dentro de /pages y será una ruta)

2- DAdo que estoy en el servidor puedo crear API Routes en el propio proyecto Next

3- Total compatibilidad con Typescript y Sass

4- Puedo exportar directamente la website estática(Static site generation)

5- Deployment más fácil.Se despliega como una app Node

                  CREAR UN PROYECTO

La Documentación( Next.js by Vercel) está aquí: https://nextjs.org/docs/getting-started
No es demasiada,y debo complimentar este curso con ella.

Para empezar un proyecto puedo usar create-next-app de forma similar(in a way alike) a como se usa create-react-app:
>npx create-next-app
IMPORTANTE: si tuviera tanto yarn como npm instalados puedo pasarle una flag para que use npm (--use-npm).Dado que solo tengo npm me va a elegir npm,esta flag es para cuando tenga tanto yarn como npm:
>npx create-next-app@latest --use-npm <- la ultima version y con npm

NOTA: fijate que podria prescindir de esta herramienta y crear un proyecto con npm init y agregarle next,react y react-dom:
>npm install next react react-dom

Puedo ver que las dependencias son mínimas(sólo esas tres,next react y react-dom),aunque usará webpack y babel behind the scenes.
Fijate que ya no estoy usando react-scripts.
Para arrancar la app ejecuto npm run dev  

Puedo ver que la estructura de Next es bastante straighforward,en la carpeta public puedo meter imagenes,svgs,y lo que meta ahi será accesible por el browser.Fijate que cualquier cosa que deje en una carpeta public puedo acceder desde el brower:
localhost:3000/favicon.ico <- veré el favicon!. 
Cualquier cosa que se deja en una carpeta public se puede acceder desde la URL

En cuanto a los estilos están en una carpeta styles y es muy común crear un .css por cada componente(como hace lama).Aqui solo tenemos uno Home.module.css que se refiere al componente Home que está en el index.js
Fijate como se importan y usan los estilos.

import styles from '../styles/Home.module.css'; <- de donde fuere.Puedo darle el nombre que quiera,estoy usando un export default implicitamente.

<main className={styles.main} > <- esta tag usará los estilos que defina para la clase main de ese archivo.
Es una convención usar ComponentName.module.css para los archivos de estilos en Next.

Fijate que se trajeron algunos UIComponents predefinidos en el ejemplo.El Head es para crear la zona Head con el title,etiquetas meta,link al favicon,etc...Asi pues deberia usarlo en cada proyecto:

import Head from 'next/head'
import Image from 'next/image'
<Head>
      <title>Create Next App</title>
      <meta name="description" content="Generated by create next app" />
      <link rel="icon" 
</Head> <- investigar más sobre estos componentes prebuilt

Fijate que cada componente debe ser una function normal que exporto por default(confirmar):

export default function Home(){
  return (
    <div>
      <Head>
      <title>Next Course</title>
      <meta name='keywords' content='web,media,next' />
      </Head>      
    </div>
  )
}
Parece que no puedo usar arrow functions.Pero fijate que lo importante es la ubicación del archivo.Dado que se trata del pages/index.js va a ser lo que se sirva en '/'.Puedo llamar al componente HomePage o Root que va a servir ése.
Fijate que lo mejor es crearse un component Head ya que lo repetiré por cada página.

El archivo _app.js es importantisimo.En realidad es la salida de la App.Es como el index.js de una app de React.Fijate que importa los estilos globales:

import '../styles/globals.css'

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}

export default MyApp

Asi pues tengo dos rutas ahora,la '/' que servirá lo que ponga en el index.js y /api/hello.
Creemos el típico folder 'component' para componentes que no serán páginas como el <Head> que queremos usar en cada page.Por convención los componentes van capitalizados en Next y las rutas no(fijate que era index.js y hello.js)
Creo el componente components/Layout.js

Fijate como puedo definir un elemento Padre que contendrá a otro:

export const Layout = ({children})
<div.container>
{children}
</div.container>
* Simplemente especifica que esto es un contenedor y que los hijos van alli,en el children.Despues cualquier componente puede envolverse con él,ya que va a ser renderizado por ese children:
import Layout from ...
export const OtherComponent = ()=> {
      return (
            <Layout>
            <h1>...</h1>
            </Layout>
      )}
* Este h1 ya va estar dentro del container.Para mi es un poco confuso,pero children se usa en el padre y ese componente Padre en el hijo.Fijate en la APIContext,uso children en el padre y ese componente wrappeando al index,como su padre.

Veamos ahora como crear una nav.Creo su archivo de estilos

ProTip: usar _rafce en vez de rafce para evitar la importacion de React de la primera linea.También funciona con otras

IMPORTANTE: puedo pasar estilos usando jsx en cualquier compontente(solo en Next??).Para ello tengo que usar una etiqueta <style jsx>{``}</style> con un objeto y backtips en su interior:

const x = 2
 <h1 className="title">
    <span>Webdev</span>
    <span>News</span>
</h1>
  <style jsx>
   {`
    .title {
      color: ${x > 3 ? 'red' : 'blue'}
    }
  `}
      </style>
    </div>
* Incluso se pueden usar estilos condicionalmente

    CUSTOM DOCUMENT

Es muy común crear un custom Document para aumentar las etiquetas html y body.Esto es necesario porque Next.js  evitan la definicion del markup del documento.
Para crearlo se crea el file /pages/_document.js y se hereda de la clase Document
Este Document se renderiza sólo en el servidor asique no puedo usar eventos como onClick en este archivo.

import Document, { Html, Head, Main, NextScript } from 'next/document'

class MyDocument extends Document {
   render() {
      return(
         <Html lang="es">
            <Head />
               <body>   
                  <Main />
                  <NextScript />
               </body>
         </Html>
      )
   }
}

export default MyDocument;

Ahora ya puedo crear mi propio Document,por ejemplo aqui le he cambiado el idioma,pero podria pasarle cualquier atributo a mi pagina.
Fijate que lo he borrado pero tengo acceso al getInitialProps(comprobar que fue esto lo que hice en el curso de micro)

        FUNCIONES ESPECIALES PARA FETCHEAR DATA

Puedo agregar estas funciones arriba o abajo del componente,es indiferente.
Hay que exportar estas funciones.
Hay tres métodos que puedo usar:
getStaticProps me permitirá hacer el fecth en build time        
getServerSideProps que hará el fetch en cada request o petición lo cual es un poco más lento 
getStaticPaths para generar dinámicamente Paths basados en la data que esté haciendo fetch

* IMPORTANTE: fijate como veré la data tanto en el front como en el back

export default function HomePage({articles}) { <- le paso articles porque es lo que devolvi con getStaticProps
  console.log(articles,'articles')
  return (
    <div>
      <Head>
        <title>Next Course</title>
        <link rel="favicon" href="favicon.ico" />
        <meta name="saludo" content="hola" />
      </Head>
      <div className={classes.flex01}>
        <h1 className={classes.h1}>Hello from Next</h1>
      </div>
    </div>
  );
}
* Hago la peticion dentro de este metodo,parece un estandar
export const getStaticProps = async () => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/todos?_limit=6`)
  const articles = await res.json();
   
  // getStaticProps devuelve un objeto y en su propiedad props que es un objeto se le pasa la data que yo quiera
  return {
    props:{
      articles
    }
  }
}
* Fijate que ya tengo la data en el cliente,asi que la puedo mapear!

            ROUTING EN NEXT

Fijate que para usar enlaces en Next me tengo que traer su Link de next/link

import Link from 'next/link'

const Article = (props) => {
   return (
      <div className={Styles.grid}>
         <Link href="/props/[id]" as={`/props/${props.id}`}>
         <a className={Styles.card}>
            <h3>{props.title} &rarr;</h3> 
            <p>{props.body}</p>
         </a>
         </Link>
      </div>
   )
Para poder ir a esa subruta tendré que crear el directorio 'props' es decir ./pages/props y otro directorio más llamado [id] (como sea que se llame el params dinámico).   
Dentro de este /pages/props/[id]/index.js  creo este file index.js
Para rescatar este parámetro dinámico tengo que usar el hook useRouter que viene de next/router,del router de next:

import {useRouter} from "next/router"

const Component = () => {
  llamar al metodo me traerá cualquier params
  const router = useRouter();
  //fijate que sé que se llama id
  const { id } = router.query; <- ojo con el query
  

}


Asi pues si quisiera ir a users/:mongoId tendría que crear ./pages/users/[mongoId]/index.js.
Si quisiera ir a auth/login tendré que crear ./pages/auth/login.js

Por otro lado getServerSideProps() trae la data en cada petición.Fijate que parece obligatorio retornar algo.Y fijate como si sé que tengo algo en los params puedo usar el context(también lo podría haber usado en getStaticProps)


const Article = ({article}) => {
   const router = useRouter()
   console.log(router.query)
   const { id } = router.query   
   return (
      <div>
         <h1 className="titulo">This is the Article {id}</h1>
         <h1 className="titulo">{`This is the Article ${id}`} Para que ponerlo asi,asinto</h1>
         <Link href="/" >Volver al Home</Link>
         <style jsx>
            {`
            .titulo {
               cursor:not-allowed;
               color:red!important;
            }
            `}
            </style>
      </div>
   )
}

export const getServerSideProps = async (context) => {
   const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${context.params.id}`)
   const article = await res.json();

   return {
      props:{
         article
      }
   }
}

* Fijate como en este caso hemos mandado el id por los params y aprovechamos para con eso hacer una petición automáticamente al usar getServerSideProps y popular de nuevo el articulo(claro que sería más eficaz mandarle la data,esto es para aprender)
La petición se realiza al entrar a este componente sólo,ojo.No tiene nada que ver con otros componentes.

Una fallback es una opcion alternativa que se seguirá sólo si la opción principal falla(ejemplo cons port = process.env.PORT || 3000)

GetStaticPaths va a generar la URL segun lo que yo le pase:

*Primero defino que se hará una petición a la ruta xxxxx/:id pero sin saber nada más.Alimentaré ese id mas abajo
export const getStaticProps = async (context) => {
   const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${context.params.id}`)
   const article = await res.json();
   
   return {
      props:{
         article
      }
   }
}
* Aqui pido los 100 posts,y alimento los ids extrayendolos de esa petición.Ahora se irá construyendo la URL con lo que se escriba en ella y fijate que más arriba hago la petición por cada articulo(asi que hice dos,una para traer los 100 posts y otra en cada petición??)
export const getStaticPaths = async() => {
   const res = await fetch(`https://jsonplaceholder.typicode.com/posts`)
   const articles = await res.json();
   const ids = articles.map(article => article.id);
   const paths = ids.map(id => ({
      params:{id:id.toString()}
   }))
   
   return {
      paths,
      fallback:false
   }
}

          EXPORTAR UNA WEBSITE ESTÁTICA

Puedo usar el comando 'next export' ,el cual sacará todo al dir 'out':

  "scripts": {
    "dev": "next dev",
    "build": "next build && next export", <- agregar
    "start": "next start",
    "lint": "next lint"
  },          

esto creará el buil de producción al dir '.next' pero también exporta todo como un estático(un index.html).Puedo servir este html con cualquier servidor.Usaremos el paquete serve:
>npm i serve -g <-
serve -s out -p 8000 <- out es el directorio
El paquete serve es un servidor para estáticos.
IMPORTANTE: este directorio 'out' está ignorado por defecto en el .gitignore,tengo que tener cuidado con esto

              CREAR API ROUTES

Cuando cree cualquier funcion con los objetos request y esponse como argumentos dentro de pages puedo tener acceso a ellos y a cualquier data que devuelva como response:

* En /pages/api/articles/index.js
export default function handler (req,res) {
   res.status(200).json(articles);
}
*En /pages/api/articles/[id].js <- ojo con como defino una ruta dinámica
export default function handler (req,res) {
   const id = req.query.id;
   const filtered = articles.filter( article => article.id === id);
   res.status(200).json(filtered[0]); <- habría que comprobar si filtered.length > 0 si no mandar un 404
}

Si bien articles son dummy data en este proyecto en la realidad serán  datos que traeré de cualquier base de datos o por REST de otra API.Fijate que puedo hacer una petición a mi mismo backend desde cualquier otra ruta.Sin embargo fijate que aunque estoy en el mismo proyecto Next sólo soporta URLs absolutas:

Al tratar de hacer una petición desde /pages/index.js(que será resuelto a simplemente '/' ) a /pages/api/articles/[id].js(fijate como hemos metido la api en /pages/api/** ) me dará error el siguiente código:

export const getStaticProps = async()=>{
   const response = await fetch('/api/articles');
   const articles = await response.json();
   return {
      props:{
         articles
      }
   }
} ** Me dará el siguiente error =>
Server Error
TypeError: Only absolute URLs are supported
This error happened while generating the page. Any console logs will be displayed in the terminal window.

Para solucionar esto es buena idea crear un archivo de configuraciones o en su defecto usar variables de entorno:

* En /config/index.js:
const dev = process.env.NODE_ENV !== 'production'
export const server = dev ? 'http://localhost:3000' :'https://mydomain'

Fijate como puedo saber si Node está en producción o no con la prebuilt environment NODE_ENV(values: 'production' | 'development').
Hasta que no haga el build no estaré en production,estaré en development.
Ya solo queda agregar al principio el resultado de 'server' como BASE_URL:

export const getStaticProps = async () => {
  const res = await fetch(`${server}/api/articles`)
  const articles = await res.json(); 

Por último,creemos un componente Meta.js para la zona meta del head de una página html.
